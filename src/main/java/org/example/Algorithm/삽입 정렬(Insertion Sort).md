# 삽입 정렬 (Insertion Sort)

---

- 손 안의 카드를 정렬하는 방법과 유사하다.
- 새로운 카드를 기존의 정렬된 카드 사이에 올바른 자리를 찾아 삽입한다.
- 삽입 정렬은 선택 정렬과 유사하지만, 좀 더 효율적인 정렬 알고리즘이다.
- `2번째 원소부터 시작하여 그 앞의 원소들과 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입`하여 정렬하는 알고리즘이다.
- 최선의 경우 O(n)으로 빠른 효율성을 가지고 있어, 다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬 알고리즘이다.

### Process (Ascending)
- 정렬은 2번째 위치의 값을 temp에 저장
- temp와 이전에 있는 원소들과 비교하여 삽입
- 1번으로 돌아가 다음 위치의 값을 temp에 저장하고 반복한다.
```java
private static void insertionSort() {
    for (int i = 1; i < arr.length; i++) {
        int temp = arr[i];
        int prev = i - 1;

        while ((0 <= prev) && temp < arr[prev]) {
            arr[prev + 1] = arr[prev];
            prev--;
        }
        arr[prev + 1] = temp;
    }
    System.out.println(Arrays.toString(arr));
}
```

<img src="https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/insertion-sort-001.gif">

### 시간복잡도
- 최악의 경우(역으로 정렬되어 있을 경우), Selection Sort와 마찬가지로 O(n^2) 이다.
- 하지만 모두 정렬이 되어있는 경우(Optimal), 한 번씩밖에 비교를 안하므로 O(n)의 시간복잡도를 가지게 된다.
- 이미 정렬되어 있는 배열에 자료를 하나씩 삽입/제거하는 경우에는, 현실적으로 최고의 정렬 알고리즘이 되는데, 탐색을 제외한 오버헤드가 매우 적기 때문이다.

### 공간복잡도
- 주어진 배열 안에서 교환을 통해 정렬이 수행되므로 O(n)이다.

### 장점
- 알고리즘이 단순하다.
- 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
- 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다.
- 안정 정렬이다.
- 선택 정렬이나 거품 정렬과 같은 O(n^2) 알고리즘에 비교하여 상대적으로 빠르다.

### 단점
- 평균과 최악의 시간복잡도가 O(n^2)으로 비효율적이다.
- 거품정렬, 선택정렬과 마찬가지로, 배열의 길이가 길어질수록 비효율적이다.

### 추가 개념
- Selection Sort와 Insertion Sort는 k번째 반복 이후, 첫번째 k 요소가 정렬된 순서로 온다는 점에서 유사하다. 
- 하지만, Selection Sort는 k+1번째 요소를 찾기 위해 나머지 모든 요소들을 탐색하지만 
- Insertion Sort는 k+1번째 요소를 배치하는 데 필요한 만큼의 요소만 탐색하기 때문에 훨씬 효율적으로 실행된다는 차이가 있다.
# RDBMS

---

### RDBMS에서 지원하는 Transcation의 ACID에 대해서 아시나요?
- DB 트랜잭션이 안전하고 일관되게 처리되도록 보장하는 속성
- ACID
  - 원자성 : DB의 모든 작업이 완료되거나, 전혀 완료되지 않는 것을 보장한다. 일부만 실행되는 경우는 없다.
  - 일관성 : 트랜잭션이 시작되기 전과 완료된 후의 데이터 상태는 무결성 제약 조건을 만족해야 한다.
  - 격리성 : 여러 트랜잭션이 동시에 수행되더라도 서로의 작업이 간섭받지 않도록 보장하는 속성. 트랜잭션은 독립적으로 수행되어야 한다.
  - 지속성 : 트랙잭션이 완료된 후에도 시스템 오류가 발생하더라도 그 결과가 영구적으로 반영되어야 한다.

### 인덱스는 왜 사용하는 것인가요?
- 인덱스는 책의 목차나 색인과 유사한 역할을 하며, 대량의 데이터를 빠르게 검색할 수 있게 한다.
- DB 테이블을 조회할 때 조회 속도를 향상시키기 위해 사용된다.
- 인덱스는 테이블의 특정 열에 대한 정렬된 데이터 구조를 유지한다.
  - DB는 전체 테이블을 순차적으로 검색할 필요 없이, 인덱스를 사용해 필요한 데이터에 빠르게 접근할 수 있다.

### 인덱스는 크게 Hash 인덱스와 B-Tree 인덱스가 있습니다. 어떠한 차이가 있을까요?
- Hash 인덱스
  - 해시 함수를 사용하여 데이터를 인덱싱하는 방식
  - 특정 키 값을 해시 함수에 입력하면 고유한 해시 값이 생성되고, 이 해시 값을 사용해 데이터가 저장될 위치를 결정한다.
  - 정확한 값 매칭(=)에 대해 빠른 검색 속도를 제공한다.
  - 해시 함수는 데이터의 순서 정보를 제공하지 않기 때문에 범위 검색에는 적합하지 않는다.
  - 다중 키 검색에도 어려움이 있다.
  - 정확한 키 조회가 필요한 경우 유리한데, `특정 ID나 고유한 키 값을 기준으로 데이터를 검색할 때 효과적`이다.
- B-Tree 인덱스
  - 균형 트리 구조를 사용하여 데이터를 인덱싱하는 방식으로, 가장 일반적으로 사용되는 인덱스 유형이다.
  - 트리의 각 노드가 여러 개의 키와 자식 노드를 가지며, 트리의 깊이 균형을 이루도록 한다.
  - 어느 한쪽으로 치우쳐져 있지 않고 각 레벨과 그 레벨의 노드의 수를 균일하게 유지하여 빠르게 조회할 수 있다.
  - 범위 검색 가능, 다중 키 검색 가능, 빠른 검색과 데이터 순회 작업에도 효율적
  - 범위 검색이나 순차적 데이터 검색이 필요한 경우 유리하다.

### B-Tree 인덱스와 B+-Tree 인덱스의 차이는 무엇인가요?

### 인덱스 Scan 방식은 무엇이 있나요?
- 인덱스를 이용해 데이터를 검색하는 다양한 방법
- 풀 인덱스 스캔 (Full Index Scan) : 테이블의 모든 데이터를 인덱스를 통해 순차적으로 스캔하는 방식 
  - SELECT * FROM customers
- 범위 스캔 (Range Scan) : 범위 조건을 만족하는 데이터만 인덱스를 통해 검색하는 방식
  - SELECT * FROM customers WHERE age > 30 AND age < 40
- 유니크 스캔 (Unique Scan) : 특정 값이 정확히 하나의 결과를 반환할 때 사용된다. 기본키나 유니크 제약 조건이 있는 열에서 데이터를 조회할 때 사용된다.
  - SELECT * FROM users WHERE user_id = 12345
- 인덱스 스킵 스캔 (Index Skip Scan) : 2개 이상의 인덱스로 구성되어 있을 때, 선행 열을 포함하지 않는 쿼리를 실행할 때 사용된다.
  - 인덱스가 user_id, last_name으로 구성되어 있다면, WHERE last_name = 'Smith' 와 같은 쿼리에서 user_id는 포함되지 않았지만, 인덱스를 사용할 수 있는 경우에 해당한다.
  - 일부 열만 사용한 검색에서도 인덱스를 활용할 수 있어, 인덱스 범용성을 높여준다.
- 인덱스 전방(Forward)/역방향(BackWard) 스캔 : 인덱스가 오름차순/내림차순으로 정렬된 상태에서 데이터를 검색하는 방식
  - SELECT * FROM customers ORDER BY cutomer_id asc
  - SELECT * FROM customers ORDER BY cutomer_id desc
- 인덱스 스캔 방식을 선택하는 기준
  - 인덱스 유무 : 해당 열에 인덱스가 정의되어 있으면, 그 인덱스를 사용하여 데이터를 검색합니다.
  - 쿼리 조건 : WHERE 절에서 사용하는 조건에 따라 범위 스캔, 유니크 스캔 등이 선택됩니다.
  - 복합 인덱스 : 복합 인덱스를 사용할 때, 쿼리에 포함된 열이 어떤 열인지에 따라 인덱스 스킵 스캔이 선택될 수 있다.
  - 결과의 크기 : 쿼리의 결과가 많은 행을 반환해야 한다면 풀 인덱스 스캔이 선택될 수 있으며, 적은 행을 반환할 경우 범위 스캔이 더 적합하다.

### 트랜잭션 격리 수준 (Transcation Isolation Level)
- 동시에 여러 트랜잭션이 수행될 떄 각 트랜잭션이 서로에게 얼마나 영향을 미칠 수 있는지를 정의하는 규칙
  - 트랜잭션이 격리되지 않으며, DB에서 동시에 실행되는 트랜잭션 간의 충돌이 발생할 수 있다.
- READ UNCOMMITTED (읽기 미완료 허용)
  - 다른 트랜잭션에서 `아직 커밋되지 않은` 데이터를 읽을 수 있는 수준
  - `가장 낮은 격리 수준`으로 동시성은 높지만, 데이터 일관성 문제가 발생한다.
  - Dirty Read (더티 읽기) : 한 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽을 수 있다.
  - **데이터의 일관성이 중요하지 않고 동시성이 높은 시스템에서 사용**
- READ COMMITTED (읽기 완료 허용)
  - 다른 트랜잭션에서 `커밋된` 데이터만 읽을 수 있는 수준
  - 대부분의 DBMS에서 기본적으로 사용하는 수준으로, '더티 읽기'는 방지하지만, '반복 불가능 읽기'는 해결하지 않는다.
  - Non-repeatable Read (반복 불가능 읽기): 같은 트랜잭션 내에서 동일한 쿼리를 두 번 실행했을 때, 중간에 다른 트랜잭션이 데이터를 변경하면 두 쿼리의 결과가 다를 수 있다.
  - **기본적으로 사용되며, 성능과 일관성의 균형을 고려한 선택**
- REPEATABLE READ (반복 가능 읽기)
  - 트랜잭션이 데이터를 읽으면 그 트랜잭션 동안 해당 데이터는 `변경되지 않음`을 보장하는 수준
  - '더티 읽기'와 '반복 불가능 읽기'를 방지하지만, '팬텀 읽기'는 해결하지 못한다.
  - Phantom Read (팬텀 읽기) : 트랜잭션 내에서 동일한 쿼리를 여러 번 실행할 때, 다른 트랜잭션이 데이터를 삽입하여 새로운 행이 나타날 수 있다.
  - **트랜잭션 중 데이터 변경을 허용하지 않아야 할 때 사용**
- SERIALIZABLE (직렬화)
  - 가장 높은 격리 수준으로, 트랜잭션이 마치 순차적으로 실행된 것처럼 동작한다.
  - 트랜잭션이 완료되기 전까지 다른 트랜잭션이 해당 데이터에 접근할 수 없다.
  - 모든 동시성 문제(더티 읽기, 반복 불가능 읽기, 팬텀 읽기)를 해결하지만, 성능은 가장 낮다.
  - 동시 실행 트랜잭션 간의 충돌을 방지하기 위해 높은 수준의 잠금이 필요하기 때문에 성능이 떨어질 수 있다.
  - **가장 엄격한 일관성을 요구할 때, 성능보다 데이터 정확성이 더 중요한 경우에 사용**

### 클러스터 인덱스와 논클러스터 인덱스는 어떤 차이가 있나요?
- 데이터 정렬 방식과 데이터 접근 방식에 차이가 있다.
- 클러스터 인덱스
  - 테이블의 데이터 자체를 정렬한다. 즉, 테이블의 실제 데이터가 인덱스 순서대로 정렬되어 저장된다.
  - 한 테이블에 하나의 클러스터 인덱스만 생성할 수 있다. 추가로 인덱스를 생성하면 논클러스터 인덱스로 관리된다.
  - 기본 키는 종종 클러스터 인덱스로 설정된다.
  - 한 번에 데이터를 바로 접근할 수 있어 검색에 매우 빠르다. 범위 검색이나 순차적인 데이터 조회에 유리하다.
- 논클러스터 인덱스
  - 별도의 인덱스 구조로 관리되며, 실제 데이터에 대한 포인터를 가지고 있다.
  - 한 테이블에 여러 개의 논클러스터 인덱스를 생성할 수 있다. -> 논클러스터 인덱스는 실제 데이터와는 별도로 관리되기 때문
  - 자주 검색되지만 정렬이 필요하지 않은 컬럼에 설정할 수 있다.
    - student_name 컬럼을 기준으로 정렬된 인덱스 트리를 만들어 놓고, 각 인덱스 항목은 해당 레코드의 물리적인 위치를 가르킨다.
    - 다중 컬럼이나 자주 조회되는 컬럼에 대해 설정하며, 클러스터 인덱스가 이미 존재하는 테이블에서 보조적인 검색 성능 향상을 위해 사용된다.
- 클러스터 인덱스는 테이블의 데이터를 물리적으로 정렬하여 저장하고, 논클러스터 인덱스는 별도 인덱스 트리로 데이터의 포인터를 저장하는 방식이다.

### 인덱스 설계시 NULL값은 고려되야 할까요? 고려해야 한다면 어떤 이유인가요?

### 좋은 인덱스를 설계하기 위해 고려해야 하는 조건으로는 무엇이 있는지 아시나요?

### 인덱스 적용이 어려운 요인에는 무엇이 있을까요?

### Nested Loop 조인은 무엇일까요?

### 데이터베이스 레플리케이션이 무엇이고 왜 사용하는지 아시나요?
- 데이터를 한 서버에서 다른 서버로 복제하여 여러 DB 서버가 동일한 데이터를 보유하도록 하는 기술
  - 마스터(Primary) : 데이터 변경 작업(쓰기 작업)을 담당하는 주 서버
  - 슬레이브(Replica) : 마스터로부터 데이터를 복제받아 읽기 작업을 처리하는 보조 서버
    - 마스터의 변경 사항을 지속적으로 반영하여 데이터를 동기화한다.
- 마스터 서버에서 장애가 발생하더라도 슬레이브 서버에서 데이터를 읽을 수 있어 서비스 중단 방지가 가능하다.
- 읽기 작업을 슬레이브 서버로 분산하여 읽기 성능을 최적화할 수 있다.

### 데이터베이스 레플리케이션의 실행 방식을 설명해주세요.
- 동기 레플리케이션
  - 마스터에서 슬레이브로 즉시 복제
  - 마스터에서 데이터가 변경되면, 그 데이터는 모든 슬레이브 서버에 복제된 후에야 트랜잭션이 완료된다.
  - 일관성을 보장하지만, 네트워크 지연이나 슬레이브 서버의 성능에 따라 속도가 느려질 수 있다.
- 비동기 레플리케이션
  - 동기 레플리케이션과는 반대로, 즉시 복제되지 않고, 일정한 주기로 데이터를 복제한다.
  - 일관성 측면에서는 지연이 발생할 수 있지만, 시스템 성능에 큰 영향을 주지 않으므로 성능이 중요한 환경에서 사용된다.
- 단방향 레플리케이션
  - 데이터가 마스터에서 슬레이브로 한 방향으로만 복제된다.
  - 일반적인 레플리케이션 방식으로, 슬레이브는 읽기 작업에만 사용되고 데이터 쓰기는 마스터에서만 가능하다.
- 다중 레플리케이션
  - 여러 마스터 서버가 존재하며, 각 마스터에서 데이터가 변경될 수 있다.
  - 데이터 충돌을 해결하는 메커니즘이 필요하며, 관리가 복잡해질 수 있다.
  - 분산된 시스템에서 쓰기 작업의 확장성을 높이기 위해 사용된다.
- 체인 레플리케이션
  - 마스터-슬레이브 구조에서 슬레이브가 또 다른 슬레이브로 데이터를 복제하는 방식
  - 복제의 확장성을 높이기 위한 구조

### 데이터베이스 레플리케이션시 발생하는 문제점은 무엇이 있을까요?
- 복잡성 증가 : 여러 서버 간의 데이터 동기화 문제와 데이터 충돌을 처리하는 메커니즘이 필요해 관리가 복잡하다.
- 일관성 문제 : 비동기 레플리케이션의 경우, 슬레이브 서버의 데이터가 마스터와 동기화되지 않을 수 있어 일관성 문제가 발생할 수 있다.
- 지연 : 데이터 복제가 지연되면 슬레이브 서버에서 최신 데이터를 보장할 수 없기 때문에 실시간성이 중요한 서비스에는 주의가 필요하다.

### 데이터베이스 정규화와 역정규화는 무엇인가요?
- 정규화
  - 테이블 간에 중복된 데이터를 허용하지 않는다는 것.
  - 중복된 데이터를 허용하지 않음으로써 무결성을 유지할 수 있으며, DB 저장 용량을 줄일 수 있다.
  - 제1정규형 : 각 컬럼에 원자 값(더 이상 나눌 수 없는 값)만 저장.
    - 각 컬럼에 하나의 값만 들어갈 수 있다.
  - 제2정규형 : 부분 종속성 제거. 기본 키의 일부가 아닌 모든 속성은 기본 키 전체에 종속되어야 함.
  - 제3정규형 : 이행적 종속성 제거. 기본 키 이외의 다른 컬럼 간에 종속성이 없어야 함.
    - A -> B, B -> C 가 성립할 때, A -> C가 성립되는 것을 의미
  - 정규화는 데이터 삽입, 삭제, 수정이 빈번하고 데이터 무결성이 중요한 시스템에서 주로 사용된다.
- 역정규화
  - 정규화된 데이터를 일부러 중복하거나, 정규화를 풀어서 DB 성능을 최적화하는 방법.
  - 주로 읽기 성능을 높이기 위해 사용된다. 복잡한 조인이나 여러 테이블을 거치는 경우 성능이 저하될 수 있기 때문에 사용한다.
- 정규화와 역정규화는 상호 보완적 기술

### 데이터베이스 파티셔닝은 무엇인가요?

### 데이터베이스 샤딩은 무엇이고 어떤 종류가 있는지 아시는데로 말씀해주세요.

### 레인지, 모듈러 샤딩 방식은 무엇이고 어느 장, 단점이 존재하나요?

### 모듈러 샤딩 방식을 확장해야할 때 사용할 수 있는 방법에는 무엇이 있고, 어떤 Trade Off들이 있나요?

### 인덱스(Index Server) 샤딩 방식에 대해서 아시나요?

### 2-Phase Commit이 무엇인지 아시나요?

### S lock, IS lock, X lock, IX lock에 대해서 아시나요?

### Optimistic Lock에 대해서 아시나요?

### InnoDB의 Consistent Non-Locking Read 기능이 무엇인지 아시나요?

### Gap, Record, Next Key Lock에 대해서 아시나요?

### 많은 사용자들에게 News feed를 제공하는 서비스가 있고, 주간 인기 Feed를 보여주는 것과 일간 Feed를 보여주는 페이지가 있다고 가정할 많은 량의 읽기 트래픽이 존재한다면 어떻게 대처할 수 있을지 말씀해보세요. (주간 인기 Feed에 대한 대처와 일간 Feed에 대한 대처)

### NoSQL과 RDBMS의 차이는 무엇이 있을까요?

### (RDBMS와 비교 했을 때) NoSQL가 가지는 장점은 무엇이 있을까요?

### NoSQL에서 지원하는 Transcation의 BASE에 대해서 아시나요?

### MongoDB의 Compound-key Index란 무엇인가요?

### MongoDB의 Compound-key Index 선언 시 효율을 높이기 위해서 포함하는 필드 순서를 어떻게 정의하면 좋을까요?

### Write Conflict 발생 시 MongoDB는 어떻게 이를 해결하려고 시도할까요?

### readConcern Option은 어떠한 이점을 제공할까요? (read staleness)

### readConcern Option의 linerizable과 majority 속성은 어떤 차이가 있나요?

### writeConcern Option은 어떠한 이점을 제공할까요?

### replicaset을 구성할 때 buildIndexes false로 설정하는 경우는 어떤 것을 위해서 사용하는 것인가요?

### MongoDB Cluster의 구성 요소로는 무엇이 있나요?

### Journaling은 무엇이고, MongoDB의 Journal은 어떠한 방식으로 구현되어 있나요?

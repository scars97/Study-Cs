# 2일차

---

### DockerFile 작성
Dockerfile은 도커 이미지를 구축하기 위해 명령어들을 순차적으로 나열한 텍스트 파일이다. 각각의 명령어는 이미지의 새로운 계층을 만들어 내며, 이러한 계층들이 합쳐져 최종적인 이미지를 형성한다. Dockerfile 작성의 기본 구조와 주요 명령어는 다음과 같다:
```
# 1단계: Maven 또는 Gradle을 사용하여 Spring Boot 애플리케이션 빌드
FROM maven:3.6.3-jdk-11 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn -f pom.xml clean package
```

```
# 2단계: JAR 파일을 실행하기 위한 새로운 레이어
FROM openjdk:11
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]
```
```
1. Maven 기반 이미지를 사용하여 소스 코드를 컨테이너 내부로 복사하고, Maven을 사용해 애플리케이션을 빌드
2. OpenJDK 기반 이미지를 사용하여 빌드 단계에서 생성된 JAR 파일을 복사하고, Java 애플리케이션을 실행

### 기본 구조 및 명령어

1. FROM: 기반 이미지를 지정한다. 모든 `Dockerfile`은 `FROM` 명령어로 시작해야 하며, 이는 빌드 과정의 기점이 되는 이미지를 정의한다.
   dockerfile
   FROM ubuntu:18.04
   
2. LABEL: 이미지에 메타데이터를 추가한다. 예를 들어, 이미지의 제작자 정보를 포함할 수 있다.
   LABEL maintainer="name@example.com"

3. RUN: 이미지 빌드 과정 중에 명령어를 실행한다. 주로 패키지 설치나 설정 파일 변경에 사용된다.
   RUN apt-get update && apt-get install -y python
   
4. COPY: 호스트의 파일이나 디렉토리를 이미지 내부로 복사한다. 애플리케이션의 소스 코드를 이미지에 추가할 때 주로 사용된다.
   COPY . /app

5. ADD: COPY 명령어와 유사하지만, 원격 URL에서 파일을 추가하거나 로컬의 압축 파일을 압축 해제하며 파일을 추가할 수 있다.
   ADD https://example.com/big.tar.xz /usr/src/things/
   
6. CMD: 컨테이너가 시작될 때 실행할 기본 명령어를 정의한다. Dockerfile 내에서 한 번만 사용할 수 있다.
   CMD ["python", "./app/app.py"]

7. EXPOSE: 컨테이너가 리스닝할 포트를 지정한다. 네트워킹 구성에 도움을 준다.
   EXPOSE 80

8. ENV: 환경 변수를 설정한다. 애플리케이션 설정에 사용된다.
   ENV API_KEY="YOUR_API_KEY"

9. WORKDIR: RUN, CMD, ENTRYPOINT, COPY, ADD 명령어가 실행될 작업 디렉토리를 설정한다.
   WORKDIR /app

10. ENTRYPOINT: 컨테이너가 시작될 때 실행할 명령어를 설정한다. CMD와 함께 사용되어 애플리케이션의 실행 방식을 정의할 수 있다.
    ENTRYPOINT ["python"]
    CMD ["app.py"]
```
- Dockerfile을 준비한 후에는 docker build 명령어를 통해 이미지를 빌드할 수 있다.
- 이때 Dockerfile 내의 지시어들이 순서대로 실행되어 최종 이미지가 생성된다. 
- Dockerfile을 활용함으로써 애플리케이션의 빌드와 배포 과정을 표준화하고 자동화할 수 있으며, 이는 개발의 효율성을 높이는 데 기여한다.
- LEGO 처럼 조립하는 개념

---

### 도커 이미지 최적화
도커 이미지의 크기를 줄이기 위한 Dockerfile 최적화 전략에는 여러 방법이 있다. 이미지의 효율성을 높이고, 배포 시간을 단축하며, 보안을 강화하는 데 중요하다. 여기 몇 가지 핵심 전략과 멀티 스테이지 빌드에 대한 자세한 설명을 추가해본다:

**경량 베이스 이미지 사용**
- 가능한 가장 경량의 베이스 이미지를 사용한다. 예를 들어, alpine 이미지는 매우 작은 크기로 필요한 최소한의 기능만 포함한다.

**멀티 스테이지 빌드 사용하기**
- Dockerfile에서 멀티 스테이지 빌드를 사용하여 빌드 단계에만 필요한 도구를 최종 이미지에서 제외시킨다. 이 방식을 사용하면 최종 이미지에는 애플리케이션 실행에 필요한 파일과 디펜던시만 포함된다. 멀티 스테이지 빌드는 여러 개의 FROM 명령어를 사용하여 구현되며, 각 스테이지는 독립적인 베이스 이미지를 가질 수 있다. 첫 번째 스테이지에서는 빌드에 필요한 도구와 소스 코드를 컴파일하는 데 필요한 작업을 수행한다. 이후 스테이지에서는 첫 번째 스테이지에서 생성된 아티팩트만을 가져와서 최종 이미지를 생성한다. 이렇게 하면 불필요한 빌드 도구나 중간 생성물을 최종 이미지에서 제외할 수 있어 이미지 크기가 상당히 줄어든다.

**필요 없는 파일 제거**
- 빌드 과정에서 생성되는 임시 파일, 캐시 파일 등 필요 없는 파일은 RUN 명령어에서 && rm -rf /path/to/temporary/files와 같이 제거하여 이미지 크기를 줄인다.

**레이어 수 최소화하기**
- RUN, COPY, ADD 명령어는 새로운 레이어를 생성한다. 이러한 명령어를 적절히 조합하여 가능한 한 적은 수의 레이어를 생성하도록 Dockerfile을 최적화한다.

**Copy와 Add 명령어 신중하게 사용하기**
- COPY와 ADD는 필요한 파일만 이미지에 추가하도록 사용한다. .dockerignore 파일을 사용하여 불필요한 파일이 이미지에 포함되지 않도록 설정할 수 있다.

**환경 변수를 이용한 설정하기**
- 가능한 설정 파일 대신 환경 변수를 사용하여 애플리케이션을 구성한다. 이 방법은 설정 변경이 필요할 때 이미지를 다시 빌드하지 않아도 되므로 이미지 크기를 줄이는 데 도움이 된다.

**적절한 태그 사용**
- 필요한 소프트웨어의 적절한 버전을 지정하여 불필요한 업데이트로 인한 크기 증가를 피한다.

---

### 컨테이너 - 호스트 간 파일 복사하기
docker cp 기본구조
- 호스트에서 컨테이너로 파일이나 디렉토리 복사
  - docker cp <호스트의 파일 경로> <컨테이너 이름>:<컨테이너 내 경로>
- 컨테이너에서 호스트로 파일이나 디렉토리 복사
  - docker cp <컨테이너 이름>:<컨테이너 내 파일 경로> <호스트의 경로>

docker cp 명령어를 사용할 때, 컨테이너 이름 대신 컨테이너 ID를 사용할 수도 있다. 또한, 디렉토리를 복사할 때는 디렉토리 내의 모든 파일과 하위 디렉토리가 함께 복사된다.

이 명령어는 로그 파일, 설정 파일, 애플리케이션의 데이터 등 컨테이너 내부나 외부에서 필요한 데이터를 쉽게 이동시키는 데 유용하다. 그러나, 컨테이너의 실행 중인 서비스에 필수적인 파일을 변경하거나 삭제할 때는 주의가 필요하다.

---

### Docker compose 개념
- 도커 컴포즈(Docker Compose)는 여러 컨테이너를 정의하고 실행하기 위한 도구다. YAML 파일을 사용하여 애플리케이션의 서비스, 네트워크, 볼륨 등을 구성하며, 이 파일을 기반으로 한 명령어로 모든 서비스를 빌드하고 시작할 수 있다. 도커 컴포즈는 복잡한 멀티 컨테이너 애플리케이션을 쉽게 관리하고, 개발, 테스팅, 스테이징, 프로덕션 환경에서의 일관성을 보장하는 데 유용하다.

**1. 간편한 구성**
- docker-compose.yml 파일 하나로 전체 애플리케이션 스택의 설정을 관리할 수 있다. 이 YAML 파일에는 애플리케이션을 구성하는 모든 컨테이너, 그 컨테이너들이 사용할 이미지, 포트 매핑, 볼륨 마운트, 환경 변수 등이 정의된다.

**2. 명령어 단순화**
- 도커 컴포즈는 docker-compose up, docker-compose down 같은 간단한 명령어를 통해 서비스를 생성, 시작, 중지할 수 있다. 이는 개발 과정을 효율적으로 만들어 준다.

**3. 개발 효율성 증대**
- 개발자는 로컬 환경에서 전체 애플리케이션을 손쉽게 시뮬레이션하고 테스트할 수 있다. 컨테이너화된 환경 덕분에 다른 개발자나 환경과의 충돌 없이 독립적으로 작업할 수 있다.

**4. 환경 일관성 보장**
- 도커 컴포즈를 사용하면 개발부터 프로덕션까지 애플리케이션의 환경을 일관되게 유지할 수 있다. 이는 "개발 환경에서는 잘 동작했는데, 실제 환경에서는 안 된다"는 문제를 방지해 준다.

**5. 다중 서비스 관리**
- 복잡한 애플리케이션을 구성하는 다수의 서비스(예: 데이터베이스, 백엔드, 프론트엔드 등)를 한 번에 관리할 수 있다. 각 서비스는 독립적인 컨테이너로 실행되지만, 도커 컴포즈를 통해 서로 연결되고 조율된다.

도커 컴포즈는 개발 초기 단계에서부터 애플리케이션의 배포까지 전 과정에서 개발자의 작업을 단순화하고 가속화하는 효율적인 도구다.

[Docker compose 실습](https://docs.docker.com/compose/gettingstarted/)

도커 컴포즈 파일은 여러 도커 컨테이너를 정의하고 실행하기 위한 YAML 형식의 설정 파일이다. 이 파일을 통해 서비스, 네트워크, 볼륨 등을 정의하고 관리할 수 있다. 도커 컴포즈 파일의 기본 구조는 다음과 같이 구성된다:

**버전 (version)**
- 도커 컴포즈 파일의 버전을 명시한다. 버전에 따라 사용할 수 있는 구성 옵션이 다르며, 일반적으로 최신 버전을 사용하는 것이 좋다.

**서비스 (services)**
- 애플리케이션을 구성하는 컨테이너들을 정의한다. 각 서비스는 하나의 컨테이너를 의미하며, 도커 이미지, 포트 바인딩, 볼륨 마운트 등 컨테이너를 실행하기 위한 설정을 포함한다.

**네트워크 (networks)**
- 컨테이너 간 통신을 위한 네트워크를 정의한다. 사용자 정의 네트워크를 생성하여 서비스들이 통신할 수 있는 네트워크 환경을 구성할 수 있다.

**볼륨 (volumes)**
- 데이터를 영구적으로 저장하기 위한 볼륨을 정의한다. 볼륨은 컨테이너가 삭제되어도 데이터를 보존하며, 여러 컨테이너 간에 데이터를 공유할 수 있도록 한다.
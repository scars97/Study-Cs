## 객체 지향 적용

---

### 상속과 조합
- 상속은 확장에 적합 하지 않은 구조다. 수정이 어렵다.
  - 부모와 자식의 결합도가 높다.
  - 상속 구조는 결합도가 높은 설계이다.
- 상속보다는 조합을 사용하자.
- 조합과 인터페이스를 활용하는 것이 유연한 구조
  - 상속을 통한 코드의 중복 제거가 주는 이점보다, 중복이 생기더라도 유연한 구조 설계가 주는 이점이 더 크다.

### Value Object
- 도메인의 개념을 추상화하여 표현한 값 객체
  - int, long 과 같은 기본 타입처럼, VO를 정의하여 도메인 안에서의 기본 타입으로 사용할 수 있다.
- 값을 취급하기 위해서, 불변성, 동등성, 유효성 검증 등을 보장해야 한다.
  - 동등성 : 서로 다른 인스턴스여도, 내부의 값이 같으면 같은 값 객체로 취급
  - 유효성 검증 : 객체가 생성되는 시점에 값에 대한 유효성 보장
- VO는 식별자 없이, 내부의 모든 값이 다 같아야 동등한 객체로 취급한다.

### 일급 컬렉션
- 일급 시민 : 다른 요소에게 사용 가능한 모든 연산을 지원하는 요소
  - 변수 역할
  - 파라미터 역할
  - 함수 결과로 반환
- 컬렉션을 포장하면서, 컬렉션만 유일하게 필드로 가지는 객체
  - 컬렉션을 다른 객체와 동등한 레벨로 다루기 위함
  - 단 하나의 컬렉션 필드만을 가진다.
- 컬렉션을 추상화하며 의미를 담을 수 있고, 가공 로직의 보금자리가 생긴다.
- getter로 컬렉션을 반환할 일이 생긴다면 새로운 컬렉션으로 만들어서 반환하자.
  - 외부 조작 위험성

### Enum
- 상태와 행위를 한 곳에서 관리할 수 있는 추상화된 객체
- 특정 도메인 개념에 대해 그 종류와 기능을 명시적으로 표현해줄 수 있다.
- 변경이 잦은 개념은 Enum보다 DB로 관리하는 것이 나을 수 있다.

### 다형성 활용
- OCP 원칙을 지키기 위해 변화하는 것과 변하지 않는 것을 구분해야 한다.
- 조건문을 예로 들어보자
  - 변하지 않는 것(추상) : 어떤 조건을 만족하는 지를 판단하고, 그에 대한 행위가 수행되는 것이다.
  - 변하는 것(구체) : 조건 자체가 변경될 수도 있고, 행위가 변경될 수도 있다.
- 변하지 않는 것을 지켜야 변경에 닫히게 되고, 변하는 것은 유동적으로 해결할 수 있어야 확장에 열려있을 수 있다.

### 도메인 지식
- 도메인 지식은 만드는 것이 아니라 발견하는 것이다.
- 객체 지향은 현실 세계를 흉내내는 것
  - 현실 세계에서 쉽게 인지하지 못하는 개념도 도출해서 사용해야 할 때가 있다.
- 설계를 할 때, 최대한 미래를 예측해야 한다.
  - 시간이 지나 설계가 잘못되었더라도, 언제든 돌아올 수 있도록 코드를 만들어야 한다.
  - 하지만 과도한 예측을 한다면 오버 엔지니어링이 될 수 있다. -> 조기 최적화는 자제하자
  - 완벽한 설계는 없다.